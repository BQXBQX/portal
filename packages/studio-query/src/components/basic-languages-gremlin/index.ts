import { languages } from 'monaco-editor';

export const conf: languages.LanguageConfiguration = {
  comments: {
    lineComment: '//',
    blockComment: ['/*', '*/'],
  },
  brackets: [
    ['{', '}'],
    ['[', ']'],
    ['(', ')'],
  ],
  autoClosingPairs: [
    { open: '{', close: '}' },
    { open: '[', close: ']' },
    { open: '(', close: ')' },
    { open: '"', close: '"' },
    { open: "'", close: "'" },
    { open: '`', close: '`' },
  ],
  surroundingPairs: [
    { open: '{', close: '}' },
    { open: '[', close: ']' },
    { open: '(', close: ')' },
    { open: '"', close: '"' },
    { open: "'", close: "'" },
    { open: '`', close: '`' },
  ],
};

export const language = <languages.IMonarchLanguage>{
  defaultToken: '',
  tokenPostfix: `.gremlin`,
  ignoreCase: true,

  brackets: [
    { open: '{', close: '}', token: 'delimiter.curly' },
    { open: '[', close: ']', token: 'delimiter.bracket' },
    { open: '(', close: ')', token: 'delimiter.parenthesis' },
  ],

  keywords: [
    'V',
    'E',
    'addV',
    'addE',
    'has',
    'hasNot',
    'out',
    'in',
    'both',
    'outE',
    'inE',
    'bothE',
    'outV',
    'inV',
    'bothV',
    'order',
    'by',
    'select',
    'where',
    'group',
    'groupCount',
    'count',
    'sum',
    'max',
    'min',
    'mean',
    'and',
    'or',
    'not',
    'emit',
    'until',
    'repeat',
    'simplePath',
    'timeLimit',
    'tree',
    'path',
    'local',
    'limit',
    'range',
    'skip',
    'tail',
    'union',
    'fold',
    'unfold',
    'as',
    'select',
    'match',
    'project',
    'flatMap',
    'choose',
    'coalesce',
    'where',
    'dedup',
    'subgraph',
    'valueMap',
    'constant',
    'inject',
    'option',
    'sideEffect',
    'store',
    'aggregate',
    'order',
    'coin',
    'sample',
    'emit',
    'barrier',
  ],
  builtinLiterals: ['true', 'false', 'null'],
  builtinFunctions: [
    'values',
    'keys',
    'property',
    'valueMap',
    'elementMap',
    'label',
    'id',
    'identity',
    'count',
    'sum',
    'max',
    'min',
    'mean',
    'and',
    'or',
    'not',
    'coalesce',
    'constant',
    'choose',
    'filter',
    'hasNext',
    'next',
    'toList',
    'toSet',
    'iterate',
    'to',
    'from',
    'path',
    'order',
    'by',
  ],

  operators: [
    // Math operators
    '+',
    '-',
    '*',
    '/',
    '%',
    '^',
    // Comparison operators
    '=',
    '<>',
    '<',
    '>',
    '<=',
    '>=',
    '==',
    '!=',
    // Traversal operators
    '.',
    '->',
    '<-',
    '-->',
    '<--',
  ],

  escapes: /\\(?:[tbnrf\\"'`]|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
  digits: /\d+/,
  octaldigits: /[0-7]+/,
  hexdigits: /[0-9a-fA-F]+/,

  tokenizer: {
    root: [[/[{}[\]()]/, '@brackets'], { include: 'common' }],
    common: [
      { include: '@whitespace' },
      { include: '@numbers' },
      { include: '@strings' },

      // Gremlin labels on vertices/edges, e.g. (v:Label)-[e:EdgeLabel]
      [/:[a-zA-Z_][\w]*/, 'type.identifier'],
      [
        /[a-zA-Z_][\w]*(?=\()/,
        {
          cases: {
            '@builtinFunctions': 'predefined.function',
          },
        },
      ],
      [
        /[a-zA-Z_$][\w$]*/,
        {
          cases: {
            '@keywords': 'keyword',
            '@builtinLiterals': 'predefined.literal',
            '@default': 'identifier',
          },
        },
      ],
      [/`/, 'identifier.escape', '@identifierBacktick'],

      // delimiter and operator after number because of `.\d` floats and `:` in labels
      [/[;,.:|]/, 'delimiter'],
      [
        /[<>=%+\-*/^]+/,
        {
          cases: {
            '@operators': 'delimiter',
            '@default': '',
          },
        },
      ],
    ],
    numbers: [
      [/-?(@digits)[eE](-?(@digits))?/, 'number.float'],
      [/-?(@digits)?\.(@digits)([eE]-?(@digits))?/, 'number.float'],
      [/-?0x(@hexdigits)/, 'number.hex'],
      [/-?0(@octaldigits)/, 'number.octal'],
      [/-?(@digits)/, 'number'],
    ],
    strings: [
      [/"([^"\\]|\\.)*$/, 'string.invalid'], // non-terminated string
      [/'([^'\\]|\\.)*$/, 'string.invalid'], // non-terminated string
      [/"/, 'string', '@stringDouble'],
      [/'/, 'string', '@stringSingle'],
    ],
    whitespace: [
      [/[ \t\r\n]+/, 'white'],
      [/\/\*/, 'comment', '@comment'],
      [/\/\/.*$/, 'comment'],
    ],
    comment: [
      [/\/\/.*/, 'comment'],
      [/[^/*]+/, 'comment'],
      [/\*\//, 'comment', '@pop'],
      [/[/*]/, 'comment'],
    ],
    stringDouble: [
      [/[^\\"]+/, 'string'],
      [/@escapes/, 'string'],
      [/\\./, 'string.invalid'],
      [/"/, 'string', '@pop'],
    ],
    stringSingle: [
      [/[^\\']+/, 'string'],
      [/@escapes/, 'string'],
      [/\\./, 'string.invalid'],
      [/'/, 'string', '@pop'],
    ],
    identifierBacktick: [
      [/[^\\`]+/, 'identifier.escape'],
      [/@escapes/, 'identifier.escape'],
      [/\\./, 'identifier.escape.invalid'],
      [/`/, 'identifier.escape', '@pop'],
    ],
  },
};
